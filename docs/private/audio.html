<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Module audio</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 16px;
  line-height: 20px;
  color: #444;
  letter-spacing: 0.15px;
  background-color: #FDFBFA; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.3);
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

/* Nim search input */
div#searchInputDiv {
  margin-bottom: 8px;
}
div#searchInputDiv input#searchInput {
  width: 10em;
}
div.search-groupby {
  margin-bottom: 8px;
}

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 8px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  font-weight: 400;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0.25em 10px 10px 10px;
  font-size: 15px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: rgba(0, 0, 0, 0.01);
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */

ul.simple > li {
  margin-bottom: 0.5em }

ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;

  padding: 2px;
  background-color: #D3D3D3;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;

  /* For some reason on Chrome, making the font size
  smaller than 1em is causing the parent container to
  bulge slightly. So, we're stuck with inheriting 1em,
  which is sad, because 0.8em looks better... */
}
span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

</style>

<script type="text/javascript" src="../dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Module audio</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple">
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="audiodotnim_toc" href="#audiodotnim">audio.nim</a></li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#AudioFormat"
    title="AudioFormat = uint16"><wbr />Audio<wbr />Format<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioCallback"
    title="AudioCallback = proc (userdata: pointer; stream: ptr uint8; len: cint) {.cdecl.}"><wbr />Audio<wbr />Callback<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioSpec"
    title="AudioSpec = object
  freq*: cint                  ## DSP frequency -- samples per second
  format*: AudioFormat         ## Audio data format
  channels*: uint8             ## Number of channels: `1` mono, `2` stereo
  silence*: uint8              ## Audio buffer silence value (calculated)
  samples*: uint16             ## Audio buffer size in sample FRAMES \
                 ## (total samples divided by channel count)
  padding*: uint16             ## Necessary for some compile environments
  size*: uint32                ## Audio buffer size in bytes (calculated)
  callback*: AudioCallback     ## Callback that feeds the audio device  \
                         ## (`nil` to use ``queueAudio()``).
  userdata*: pointer           ## Userdata passed to callback \
                   ## (ignored for `nil` callbacks)."><wbr />Audio<wbr />Spec<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioFilter"
    title="AudioFilter = proc (cvt: ptr AudioCVT; format: AudioFormat) {.cdecl.}"><wbr />Audio<wbr />Filter<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioCVT"
    title="AudioCVT = object {.packed.}
  needed*: cint                ## Set to `1` if conversion possible
  src_format*: AudioFormat     ## Source audio format
  dst_format*: AudioFormat     ## Target audio format
  rate_incr*: cdouble          ## Rate conversion increment
  buf*: ptr uint8               ## Buffer to hold entire audio data
  len*: cint                   ## Length of original audio buffer
  len_cvt*: cint               ## Length of converted audio buffer
  len_mult*: cint              ## buffer must be `len*len_mult` big
  len_ratio*: cdouble          ## Given len, final size is `len * len_ratio`
  filters*: array[9 + 1, AudioFilter] ## \
                                 ## ``nil``-terminated list of filter functions
  filter_index*: cint          ## Current audio conversion procedure"><wbr />Audio<wbr />CVT<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioDeviceID"
    title="AudioDeviceID = uint32"><wbr />Audio<wbr />Device<wbr />ID<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioStatus"
    title="AudioStatus {.size: 4.} = enum
  AUDIO_STOPPED = 0, AUDIO_PLAYING, AUDIO_PAUSED"><wbr />Audio<wbr />Status<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioStream"
    title="AudioStream = pointer"><wbr />Audio<wbr />Stream<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#AUDIO_MASK_BITSIZE"
    title="AUDIO_MASK_BITSIZE = 0x000000FF"><wbr />AUDIO_<wbr />MASK_<wbr />BITSIZE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_MASK_DATATYPE"
    title="AUDIO_MASK_DATATYPE = 256"><wbr />AUDIO_<wbr />MASK_<wbr />DATATYPE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_MASK_ENDIAN"
    title="AUDIO_MASK_ENDIAN = 4096"><wbr />AUDIO_<wbr />MASK_<wbr />ENDIAN<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_MASK_SIGNED"
    title="AUDIO_MASK_SIGNED = 32768"><wbr />AUDIO_<wbr />MASK_<wbr />SIGNED<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_U8"
    title="AUDIO_U8 = 0x00000008"><wbr />AUDIO_<wbr />U8<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S8"
    title="AUDIO_S8 = 0x00008008"><wbr />AUDIO_<wbr />S8<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_U16LSB"
    title="AUDIO_U16LSB = 0x00000010"><wbr />AUDIO_<wbr />U16LSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S16LSB"
    title="AUDIO_S16LSB = 0x00008010"><wbr />AUDIO_<wbr />S16LSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_U16MSB"
    title="AUDIO_U16MSB = 0x00001010"><wbr />AUDIO_<wbr />U16MSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S16MSB"
    title="AUDIO_S16MSB = 0x00009010"><wbr />AUDIO_<wbr />S16MSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_U16"
    title="AUDIO_U16 = 0x00000010"><wbr />AUDIO_<wbr />U16<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S16"
    title="AUDIO_S16 = 0x00008010"><wbr />AUDIO_<wbr />S16<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S32LSB"
    title="AUDIO_S32LSB = 0x00008020"><wbr />AUDIO_<wbr />S32LSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S32MSB"
    title="AUDIO_S32MSB = 0x00009020"><wbr />AUDIO_<wbr />S32MSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S32"
    title="AUDIO_S32 = 0x00008020"><wbr />AUDIO_<wbr />S32<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_F32LSB"
    title="AUDIO_F32LSB = 0x00008120"><wbr />AUDIO_<wbr />F32LSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_F32MSB"
    title="AUDIO_F32MSB = 0x00009120"><wbr />AUDIO_<wbr />F32MSB<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_F32"
    title="AUDIO_F32 = 0x00008120"><wbr />AUDIO_<wbr />F32<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_U16SYS"
    title="AUDIO_U16SYS = 0x00000010"><wbr />AUDIO_<wbr />U16SYS<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S16SYS"
    title="AUDIO_S16SYS = 0x00008010"><wbr />AUDIO_<wbr />S16SYS<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_S32SYS"
    title="AUDIO_S32SYS = 0x00008020"><wbr />AUDIO_<wbr />S32SYS<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_F32SYS"
    title="AUDIO_F32SYS = 0x00008120"><wbr />AUDIO_<wbr />F32SYS<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_ALLOW_FREQUENCY_CHANGE"
    title="AUDIO_ALLOW_FREQUENCY_CHANGE = 0x00000001"><wbr />AUDIO_<wbr />ALLOW_<wbr />FREQUENCY_<wbr />CHANGE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_ALLOW_FORMAT_CHANGE"
    title="AUDIO_ALLOW_FORMAT_CHANGE = 0x00000002"><wbr />AUDIO_<wbr />ALLOW_<wbr />FORMAT_<wbr />CHANGE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_ALLOW_CHANNELS_CHANGE"
    title="AUDIO_ALLOW_CHANNELS_CHANGE = 0x00000004"><wbr />AUDIO_<wbr />ALLOW_<wbr />CHANNELS_<wbr />CHANGE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_ALLOW_SAMPLES_CHANGE"
    title="AUDIO_ALLOW_SAMPLES_CHANGE = 0x00000008"><wbr />AUDIO_<wbr />ALLOW_<wbr />SAMPLES_<wbr />CHANGE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AUDIO_ALLOW_ANY_CHANGE"
    title="AUDIO_ALLOW_ANY_CHANGE = 15"><wbr />AUDIO_<wbr />ALLOW_<wbr />ANY_<wbr />CHANGE<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#AudioCVTMaxFilters"
    title="AudioCVTMaxFilters = 9"><wbr />Audio<wbr />CVTMax<wbr />Filters<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#MIX_MAXVOLUME"
    title="MIX_MAXVOLUME = 128"><wbr />MIX_<wbr />MAXVOLUME<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#getNumAudioDrivers,"
    title="getNumAudioDrivers(): cint"><wbr />get<wbr />Num<wbr />Audio<wbr />Drivers<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#getAudioDriver,cint"
    title="getAudioDriver(index: cint): cstring"><wbr />get<wbr />Audio<wbr />Driver<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioInit,cstring"
    title="audioInit(driver_name: cstring): cint"><wbr />audio<wbr />Init<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioQuit,"
    title="audioQuit()"><wbr />audio<wbr />Quit<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#getCurrentAudioDriver,"
    title="getCurrentAudioDriver(): cstring"><wbr />get<wbr />Current<wbr />Audio<wbr />Driver<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#openAudio,ptr.AudioSpec,ptr.AudioSpec"
    title="openAudio(desired: ptr AudioSpec; obtained: ptr AudioSpec): cint"><wbr />open<wbr />Audio<span class="attachedType" style="visibility:hidden">AudioSpec</span></a></li>
  <li><a class="reference" href="#getNumAudioDevices,cint"
    title="getNumAudioDevices(iscapture: cint): cint"><wbr />get<wbr />Num<wbr />Audio<wbr />Devices<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#getAudioDeviceName,cint,cint"
    title="getAudioDeviceName(index: cint; iscapture: cint): cstring"><wbr />get<wbr />Audio<wbr />Device<wbr />Name<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#openAudioDevice,cstring,cint,ptr.AudioSpec,ptr.AudioSpec,cint"
    title="openAudioDevice(device: cstring; iscapture: cint; desired: ptr AudioSpec;
                obtained: ptr AudioSpec; allowed_changes: cint): AudioDeviceID"><wbr />open<wbr />Audio<wbr />Device<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#GetAudioStatus,"
    title="GetAudioStatus(): AudioStatus"><wbr />Get<wbr />Audio<wbr />Status<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#GetAudioDeviceStatus,AudioDeviceID"
    title="GetAudioDeviceStatus(dev: AudioDeviceID): AudioStatus"><wbr />Get<wbr />Audio<wbr />Device<wbr />Status<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#pauseAudio,cint"
    title="pauseAudio(pause_on: cint)"><wbr />pause<wbr />Audio<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#pauseAudioDevice,AudioDeviceID,cint"
    title="pauseAudioDevice(dev: AudioDeviceID; pause_on: cint)"><wbr />pause<wbr />Audio<wbr />Device<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#loadWAV_RW,ptr.RWops,cint,ptr.AudioSpec,ptr.ptr.uint8,ptr.uint32"
    title="loadWAV_RW(src: ptr RWops; freesrc: cint; spec: ptr AudioSpec; audio_buf: ptr ptr uint8;
           audio_len: ptr uint32): ptr AudioSpec"><wbr />load<wbr />WAV_<wbr />RW<span class="attachedType" style="visibility:hidden">AudioSpec</span></a></li>
  <li><a class="reference" href="#freeWAV,ptr.uint8"
    title="freeWAV(audio_buf: ptr uint8)"><wbr />free<wbr />WAV<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#buildAudioCVT,ptr.AudioCVT,AudioFormat,uint8,cint,AudioFormat,uint8,cint"
    title="buildAudioCVT(cvt: ptr AudioCVT; src_format: AudioFormat; src_channels: uint8;
              src_rate: cint; dst_format: AudioFormat; dst_channels: uint8;
              dst_rate: cint): cint"><wbr />build<wbr />Audio<wbr />CVT<span class="attachedType" style="visibility:hidden">AudioCVT</span></a></li>
  <li><a class="reference" href="#convertAudio,ptr.AudioCVT"
    title="convertAudio(cvt: ptr AudioCVT): cint"><wbr />convert<wbr />Audio<span class="attachedType" style="visibility:hidden">AudioCVT</span></a></li>
  <li><a class="reference" href="#newAudioStream,AudioFormat,uint8,cint,AudioFormat,uint8,cint"
    title="newAudioStream(srcFormat: AudioFormat; srcChannels: uint8; srcRate: cint;
               dstFormat: AudioFormat; dstChannels: uint8; dstRate: cint): AudioStream"><wbr />new<wbr />Audio<wbr />Stream<span class="attachedType" style="visibility:hidden">AudioFormat</span></a></li>
  <li><a class="reference" href="#audioStreamPut,AudioStream,pointer,cint"
    title="audioStreamPut(stream: AudioStream; buf: pointer; len: cint): cint"><wbr />audio<wbr />Stream<wbr />Put<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#audioStreamGet,AudioStream,pointer,cint"
    title="audioStreamGet(stream: AudioStream; buf: pointer; len: cint): cint"><wbr />audio<wbr />Stream<wbr />Get<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#audioStreamAvailable,AudioStream"
    title="audioStreamAvailable(stream: AudioStream): cint"><wbr />audio<wbr />Stream<wbr />Available<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#audioStreamFlush,AudioStream"
    title="audioStreamFlush(stream: AudioStream): cint"><wbr />audio<wbr />Stream<wbr />Flush<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#audioStreamClear,AudioStream"
    title="audioStreamClear(stream: AudioStream)"><wbr />audio<wbr />Stream<wbr />Clear<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#freeAudioStream,AudioStream"
    title="freeAudioStream(stream: AudioStream)"><wbr />free<wbr />Audio<wbr />Stream<span class="attachedType" style="visibility:hidden">AudioStream</span></a></li>
  <li><a class="reference" href="#mixAudio,ptr.uint8,ptr.uint8,uint32,cint"
    title="mixAudio(dst: ptr uint8; src: ptr uint8; len: uint32; volume: cint)"><wbr />mix<wbr />Audio<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mixAudioFormat,ptr.uint8,ptr.uint8,AudioFormat,uint32,cint"
    title="mixAudioFormat(dst: ptr uint8; src: ptr uint8; format: AudioFormat; len: uint32;
               volume: cint)"><wbr />mix<wbr />Audio<wbr />Format<span class="attachedType" style="visibility:hidden">AudioFormat</span></a></li>
  <li><a class="reference" href="#queueAudio,AudioDeviceID,pointer,uint32"
    title="queueAudio(dev: AudioDeviceID; data: pointer; len: uint32): cint"><wbr />queue<wbr />Audio<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#dequeueAudio,AudioDeviceID,pointer,uint32"
    title="dequeueAudio(dev: AudioDeviceID; data: pointer; len: uint32): cint"><wbr />dequeue<wbr />Audio<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#getQueuedAudioSize,AudioDeviceID"
    title="getQueuedAudioSize(dev: AudioDeviceID): uint32"><wbr />get<wbr />Queued<wbr />Audio<wbr />Size<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#clearQueuedAudio,AudioDeviceID"
    title="clearQueuedAudio(dev: AudioDeviceID)"><wbr />clear<wbr />Queued<wbr />Audio<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#lockAudio,"
    title="lockAudio()"><wbr />lock<wbr />Audio<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#lockAudioDevice,AudioDeviceID"
    title="lockAudioDevice(dev: AudioDeviceID)"><wbr />lock<wbr />Audio<wbr />Device<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#unlockAudio,"
    title="unlockAudio()"><wbr />unlock<wbr />Audio<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#unlockAudioDevice,AudioDeviceID"
    title="unlockAudioDevice(dev: AudioDeviceID)"><wbr />unlock<wbr />Audio<wbr />Device<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>
  <li><a class="reference" href="#closeAudio,"
    title="closeAudio()"><wbr />close<wbr />Audio<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#closeAudioDevice,AudioDeviceID"
    title="closeAudioDevice(dev: AudioDeviceID)"><wbr />close<wbr />Audio<wbr />Device<span class="attachedType" style="visibility:hidden">AudioDeviceID</span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#audioBitSize.t,untyped"
    title="audioBitSize(x: untyped): untyped"><wbr />audio<wbr />Bit<wbr />Size<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsFloat.t,untyped"
    title="audioIsFloat(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Float<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsBigEndian.t,untyped"
    title="audioIsBigEndian(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Big<wbr />Endian<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsSigned.t,untyped"
    title="audioIsSigned(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Signed<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsInt.t,untyped"
    title="audioIsInt(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Int<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsLittleEndian.t,untyped"
    title="audioIsLittleEndian(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Little<wbr />Endian<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#audioIsUnsigned.t,untyped"
    title="audioIsUnsigned(x: untyped): untyped"><wbr />audio<wbr />Is<wbr />Unsigned<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#loadWAV_RW.t,ptr.RWops,bool,ptr.AudioSpec,ptr.ptr.uint8,ptr.uint32"
    title="loadWAV_RW(src: ptr RWops; freesrc: bool; spec: ptr AudioSpec; audio_buf: ptr ptr uint8;
           audio_len: ptr uint32): ptr AudioSpec"><wbr />load<wbr />WAV_<wbr />RW<span class="attachedType" style="visibility:hidden">AudioSpec</span></a></li>
  <li><a class="reference" href="#loadWAV.t,untyped,untyped,untyped,untyped"
    title="loadWAV(file, spec, audio_buf, audio_len: untyped): untyped"><wbr />load<wbr />WAV<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  <p class="module-desc">
<h1><a class="toc-backref" id="audiodotnim" href="#audiodotnim">audio.nim</a></h1><p>Access to the raw audio mixing buffer for the SDL library.</p>
<p>Create a new audio stream</p>
<p><tt class="docutils literal"><span class="pre">src_format</span></tt> The format of the source audio</p>
<p><tt class="docutils literal"><span class="pre">src_channels</span></tt> The number of channels of the source audio <tt class="docutils literal"><span class="pre">src_rate</span></tt>     The sampling rate of the source audio <tt class="docutils literal"><span class="pre">dst_format</span></tt>   The format of the desired audio output <tt class="docutils literal"><span class="pre">dst_channels</span></tt> The number of channels of the desired audio output <tt class="docutils literal"><span class="pre">dst_rate</span></tt>     The sampling rate of the desired audio output</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> on success, or <cite>-1</cite> on error.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">freeAudioStream()</span></tt></p>
<p>Add data to be converted/resampled to the stream</p>
<p><tt class="docutils literal"><span class="pre">stream</span></tt>  The stream the audio data is being added to</p>
<p><tt class="docutils literal"><span class="pre">buf</span></tt>     A pointer to the audio data to add</p>
<p><tt class="docutils literal"><span class="pre">len</span></tt>     The number of bytes to write to the stream</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> on success, or <cite>-1</cite> on error.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">freeAudioStream()</span></tt></p>
<p>Get converted/resampled data from the stream</p>
<p><tt class="docutils literal"><span class="pre">stream</span></tt>  The stream the audio is being requested from</p>
<p><tt class="docutils literal"><span class="pre">buf</span></tt>     A buffer to fill with audio data</p>
<p><tt class="docutils literal"><span class="pre">len</span></tt>     The maximum number of bytes to fill</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of bytes read from the stream, or <cite>-1</cite> on error.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">freeAudioStream()</span></tt> </p>
<p>Get the number of converted/resampled bytes available. The stream may be buffering data behind the scenes until it has enough to resample correctly, so this number might be lower than what you expect, or even be zero. Add more data or flush the stream if you need the data now.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">freeAudioStream()</span></tt></p>
<p>Tell the stream that you're done sending data, and anything being buffered should be converted/resampled and made available immediately.</p>
<p>It is legal to add more data to a stream after flushing, but there will be audio gaps in the output. Generally this is intended to signal the end of input, so the complete output becomes available.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
<p>Clear any pending data in the stream without converting it.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">freeAudioStream()</span></tt></p>
<p>Free an audio stream.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">newAudioStream()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamPut()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamGet()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamAvailable()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamFlush()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">audioStreamClear()</span></tt></p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<dt id="AudioFormat"><a name="AudioFormat"></a><pre><a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a> <span class="Other">=</span> <span class="Identifier">uint16</span></pre></dt>
<dd>
<p>
Audio format flags.</p>
<p>These are what the 16 bits in <tt class="docutils literal"><span class="pre">AudioFormat</span></tt> currently mean... (Unspecified bits are always zero).</p>
<pre>++-----------------------sample is signed if set
||
||       ++-----------sample is bigendian if set
||       ||
||       ||          ++---sample is float if set
||       ||          ||
||       ||          || +---sample bit size---+
||       ||          || |                     |
15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00</pre>
<p>There are templates in SDL 2.0 and later to query these bits.</p>


</dd>
<dt id="AudioCallback"><a name="AudioCallback"></a><pre><a href="audio.html#AudioCallback"><span class="Identifier">AudioCallback</span></a> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">userdata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>
This procedure is called when the audio device needs more data.</p>
<p><tt class="docutils literal"><span class="pre">userdata</span></tt> An application-specific parameter saved in <tt class="docutils literal"><span class="pre">AudioSpec</span></tt> object.</p>
<p><tt class="docutils literal"><span class="pre">stream</span></tt> A pointer to the audio data buffer.</p>
<p><tt class="docutils literal"><span class="pre">len</span></tt> The length of that buffer in bytes.</p>
<p>Once the callback returns, the buffer will no longer be valid. Stereo samples are stored in a LRLRLR ordering.</p>
<p>You can choose to avoid callbacks and use <tt class="docutils literal"><span class="pre">queueAudio()</span></tt> instead, if you like. Just open your audio device with a <cite>nil</cite> callback.</p>


</dd>
<dt id="AudioSpec"><a name="AudioSpec"></a><pre><a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">freq</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                  <span class="Comment">## DSP frequency -- samples per second</span>
  <span class="Identifier">format</span><span class="Operator">*</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a>         <span class="Comment">## Audio data format</span>
  <span class="Identifier">channels</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Number of channels: `1` mono, `2` stereo</span>
  <span class="Identifier">silence</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Audio buffer silence value (calculated)</span>
  <span class="Identifier">samples</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>             <span class="Comment">## Audio buffer size in sample FRAMES \</span>
                 <span class="Comment">## (total samples divided by channel count)</span>
  <span class="Identifier">padding</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>             <span class="Comment">## Necessary for some compile environments</span>
  <span class="Identifier">size</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint32</span>                <span class="Comment">## Audio buffer size in bytes (calculated)</span>
  <span class="Identifier">callback</span><span class="Operator">*</span><span class="Other">:</span> <a href="audio.html#AudioCallback"><span class="Identifier">AudioCallback</span></a>     <span class="Comment">## Callback that feeds the audio device  \</span>
                         <span class="Comment">## (`nil` to use ``queueAudio()``).</span>
  <span class="Identifier">userdata</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">pointer</span>           <span class="Comment">## Userdata passed to callback \</span>
                   <span class="Comment">## (ignored for `nil` callbacks).</span>
  </pre></dt>
<dd>
<p>
The calculated values in this object are calculated by <tt class="docutils literal"><span class="pre">OpenAudio()</span></tt>.</p>
<p>For multi-channel audio, the default SDL channel mapping is:</p>
<ul class="simple"><li>2:  FL FR                     (stereo)</li>
<li>3:  FL FR LFE                 (2.1 surround)</li>
<li>4:  FL FR BL BR               (quad)</li>
<li>5:  FL FR FC BL BR            (quad + center)</li>
<li>6:  FL FR FC LFE SL SR        (5.1 surround - last two can also be BL BR)</li>
<li>7:  FL FR FC LFE BC SL SR     (6.1 surround)</li>
<li>8:  FL FR FC LFE BL BR SL SR  (7.1 surround)</li>
</ul>


</dd>
<dt id="AudioFilter"><a name="AudioFilter"></a><pre><a href="audio.html#AudioFilter"><span class="Identifier">AudioFilter</span></a> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cvt</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioCVT"><span class="Identifier">AudioCVT</span></a><span class="Other">;</span> <span class="Identifier">format</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="AudioCVT"><a name="AudioCVT"></a><pre><a href="audio.html#AudioCVT"><span class="Identifier">AudioCVT</span></a> <span class="Other">=</span> <span class="Keyword">object</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">packed</span></span><span class="Other">.}</span></span>
  <span class="Identifier">needed</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                <span class="Comment">## Set to `1` if conversion possible</span>
  <span class="Identifier">src_format</span><span class="Operator">*</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a>     <span class="Comment">## Source audio format</span>
  <span class="Identifier">dst_format</span><span class="Operator">*</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a>     <span class="Comment">## Target audio format</span>
  <span class="Identifier">rate_incr</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cdouble</span>          <span class="Comment">## Rate conversion increment</span>
  <span class="Identifier">buf</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span>               <span class="Comment">## Buffer to hold entire audio data</span>
  <span class="Identifier">len</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                   <span class="Comment">## Length of original audio buffer</span>
  <span class="Identifier">len_cvt</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>               <span class="Comment">## Length of converted audio buffer</span>
  <span class="Identifier">len_mult</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>              <span class="Comment">## buffer must be `len*len_mult` big</span>
  <span class="Identifier">len_ratio</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cdouble</span>          <span class="Comment">## Given len, final size is `len * len_ratio`</span>
  <span class="Identifier">filters</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">9</span> <span class="Operator">+</span> <span class="DecNumber">1</span><span class="Other">,</span> <a href="audio.html#AudioFilter"><span class="Identifier">AudioFilter</span></a><span class="Other">]</span> <span class="Comment">## \</span>
                                 <span class="Comment">## ``nil``-terminated list of filter functions</span>
  <span class="Identifier">filter_index</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>          <span class="Comment">## Current audio conversion procedure</span>
  </pre></dt>
<dd>
<p>
A structure to hold a set of audio conversion filters and buffers.</p>
<p>Note that various parts of the conversion pipeline can take advantage of SIMD operations (like SSE2, for example). <tt class="docutils literal"><span class="pre">AudioCVT</span></tt> doesn't require you to pass it aligned data, but can possibly run much faster if you set both its <tt class="docutils literal"><span class="pre">buf</span></tt> field to a pointer that is aligned to 16 bytes, and its <tt class="docutils literal"><span class="pre">len</span></tt> field to something that's a multiple of 16, if possible.</p>
<p>This structure is 84 bytes on 32-bit architectures, make sure GCC doesn't pad it out to 88 bytes to guarantee ABI compatibility between compilers. The next time we rev the ABI, make sure to size the ints and add padding.</p>


</dd>
<dt id="AudioDeviceID"><a name="AudioDeviceID"></a><pre><a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a> <span class="Other">=</span> <span class="Identifier">uint32</span></pre></dt>
<dd>
<p>
SDL Audio Device IDs.</p>
<p>A successful call to <tt class="docutils literal"><span class="pre">openAudio()</span></tt> is always device id <cite>1</cite>, and legacy SDL audio APIs assume you want this device ID. <tt class="docutils literal"><span class="pre">openAudioDevice()</span></tt> calls always returns devices &gt;= <cite>2</cite> on success. The legacy calls are good both for backwards compatibility and when you don't care about multiple, specific, or capture devices.</p>


</dd>
<dt id="AudioStatus"><a name="AudioStatus"></a><pre><a href="audio.html#AudioStatus"><span class="Identifier">AudioStatus</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">size</span><span class="Other">:</span> <span class="DecNumber">4</span></span><span class="Other">.}</span></span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">AUDIO_STOPPED</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">AUDIO_PLAYING</span><span class="Other">,</span> <span class="Identifier">AUDIO_PAUSED</span></pre></dt>
<dd>


</dd>
<dt id="AudioStream"><a name="AudioStream"></a><pre><a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>
<p>
<tt class="docutils literal"><span class="pre">AudioStream</span></tt> is a new audio conversion interface.</p>
<p>The benefits vs <tt class="docutils literal"><span class="pre">AudioCVT</span></tt>:</p>
<ul class="simple"><li>it can handle resampling data in chunks without generating artifacts, when it doesn't have the complete buffer available.</li>
<li>it can handle incoming data in any variable size.</li>
<li>You push data as you have it, and pull it when you need it.</li>
</ul>
<p>This is opaque to the outside world.</p>


</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<dt id="AUDIO_MASK_BITSIZE"><a name="AUDIO_MASK_BITSIZE"></a><pre><span class="Identifier">AUDIO_MASK_BITSIZE</span> <span class="Other">=</span> <span class="DecNumber">0x000000FF</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_MASK_DATATYPE"><a name="AUDIO_MASK_DATATYPE"></a><pre><span class="Identifier">AUDIO_MASK_DATATYPE</span> <span class="Other">=</span> <span class="DecNumber">256</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_MASK_ENDIAN"><a name="AUDIO_MASK_ENDIAN"></a><pre><span class="Identifier">AUDIO_MASK_ENDIAN</span> <span class="Other">=</span> <span class="DecNumber">4096</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_MASK_SIGNED"><a name="AUDIO_MASK_SIGNED"></a><pre><span class="Identifier">AUDIO_MASK_SIGNED</span> <span class="Other">=</span> <span class="DecNumber">32768</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_U8"><a name="AUDIO_U8"></a><pre><span class="Identifier">AUDIO_U8</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span></pre></dt>
<dd>
Unsigned 8-bit samples

</dd>
<dt id="AUDIO_S8"><a name="AUDIO_S8"></a><pre><span class="Identifier">AUDIO_S8</span> <span class="Other">=</span> <span class="DecNumber">0x00008008</span></pre></dt>
<dd>
Signed 8-bit samples

</dd>
<dt id="AUDIO_U16LSB"><a name="AUDIO_U16LSB"></a><pre><span class="Identifier">AUDIO_U16LSB</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span></pre></dt>
<dd>
Unsigned 16-bit samples

</dd>
<dt id="AUDIO_S16LSB"><a name="AUDIO_S16LSB"></a><pre><span class="Identifier">AUDIO_S16LSB</span> <span class="Other">=</span> <span class="DecNumber">0x00008010</span></pre></dt>
<dd>
Signed 16-bit samples

</dd>
<dt id="AUDIO_U16MSB"><a name="AUDIO_U16MSB"></a><pre><span class="Identifier">AUDIO_U16MSB</span> <span class="Other">=</span> <span class="DecNumber">0x00001010</span></pre></dt>
<dd>
As above, but big-endian byte order

</dd>
<dt id="AUDIO_S16MSB"><a name="AUDIO_S16MSB"></a><pre><span class="Identifier">AUDIO_S16MSB</span> <span class="Other">=</span> <span class="DecNumber">0x00009010</span></pre></dt>
<dd>
As above, but big-endian byte order

</dd>
<dt id="AUDIO_U16"><a name="AUDIO_U16"></a><pre><span class="Identifier">AUDIO_U16</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_S16"><a name="AUDIO_S16"></a><pre><span class="Identifier">AUDIO_S16</span> <span class="Other">=</span> <span class="DecNumber">0x00008010</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_S32LSB"><a name="AUDIO_S32LSB"></a><pre><span class="Identifier">AUDIO_S32LSB</span> <span class="Other">=</span> <span class="DecNumber">0x00008020</span></pre></dt>
<dd>
32-bit integer samples

</dd>
<dt id="AUDIO_S32MSB"><a name="AUDIO_S32MSB"></a><pre><span class="Identifier">AUDIO_S32MSB</span> <span class="Other">=</span> <span class="DecNumber">0x00009020</span></pre></dt>
<dd>
As above, but big-endian byte order

</dd>
<dt id="AUDIO_S32"><a name="AUDIO_S32"></a><pre><span class="Identifier">AUDIO_S32</span> <span class="Other">=</span> <span class="DecNumber">0x00008020</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_F32LSB"><a name="AUDIO_F32LSB"></a><pre><span class="Identifier">AUDIO_F32LSB</span> <span class="Other">=</span> <span class="DecNumber">0x00008120</span></pre></dt>
<dd>
32-bit floating point samples

</dd>
<dt id="AUDIO_F32MSB"><a name="AUDIO_F32MSB"></a><pre><span class="Identifier">AUDIO_F32MSB</span> <span class="Other">=</span> <span class="DecNumber">0x00009120</span></pre></dt>
<dd>
As above, but big-endian byte order

</dd>
<dt id="AUDIO_F32"><a name="AUDIO_F32"></a><pre><span class="Identifier">AUDIO_F32</span> <span class="Other">=</span> <span class="DecNumber">0x00008120</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_U16SYS"><a name="AUDIO_U16SYS"></a><pre><span class="Identifier">AUDIO_U16SYS</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_S16SYS"><a name="AUDIO_S16SYS"></a><pre><span class="Identifier">AUDIO_S16SYS</span> <span class="Other">=</span> <span class="DecNumber">0x00008010</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_S32SYS"><a name="AUDIO_S32SYS"></a><pre><span class="Identifier">AUDIO_S32SYS</span> <span class="Other">=</span> <span class="DecNumber">0x00008020</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_F32SYS"><a name="AUDIO_F32SYS"></a><pre><span class="Identifier">AUDIO_F32SYS</span> <span class="Other">=</span> <span class="DecNumber">0x00008120</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_ALLOW_FREQUENCY_CHANGE"><a name="AUDIO_ALLOW_FREQUENCY_CHANGE"></a><pre><span class="Identifier">AUDIO_ALLOW_FREQUENCY_CHANGE</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_ALLOW_FORMAT_CHANGE"><a name="AUDIO_ALLOW_FORMAT_CHANGE"></a><pre><span class="Identifier">AUDIO_ALLOW_FORMAT_CHANGE</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_ALLOW_CHANNELS_CHANGE"><a name="AUDIO_ALLOW_CHANNELS_CHANGE"></a><pre><span class="Identifier">AUDIO_ALLOW_CHANNELS_CHANGE</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_ALLOW_SAMPLES_CHANGE"><a name="AUDIO_ALLOW_SAMPLES_CHANGE"></a><pre><span class="Identifier">AUDIO_ALLOW_SAMPLES_CHANGE</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span></pre></dt>
<dd>


</dd>
<dt id="AUDIO_ALLOW_ANY_CHANGE"><a name="AUDIO_ALLOW_ANY_CHANGE"></a><pre><span class="Identifier">AUDIO_ALLOW_ANY_CHANGE</span> <span class="Other">=</span> <span class="DecNumber">15</span></pre></dt>
<dd>


</dd>
<dt id="AudioCVTMaxFilters"><a name="AudioCVTMaxFilters"></a><pre><span class="Identifier">AudioCVTMaxFilters</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>
Upper limit of filters in <tt class="docutils literal"><span class="pre">AudioCVT</span></tt>  
The maximum number of <tt class="docutils literal"><span class="pre">AudioFilter</span></tt> functions in <tt class="docutils literal"><span class="pre">AudioCVT</span></tt> is currently limited to <cite>9</cite>. The <tt class="docutils literal"><span class="pre">AudioCVT.filters</span></tt> array has 10 pointers, one of which is the terminating <tt class="docutils literal"><span class="pre">nil</span></tt> pointer.

</dd>
<dt id="MIX_MAXVOLUME"><a name="MIX_MAXVOLUME"></a><pre><span class="Identifier">MIX_MAXVOLUME</span> <span class="Other">=</span> <span class="DecNumber">128</span></pre></dt>
<dd>


</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="getNumAudioDrivers"><a name="getNumAudioDrivers,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getNumAudioDrivers</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetNumAudioDrivers&quot;</span><span class="Other">,</span>
                               <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Driver discovery procedures.</p>
<p>These procedures return the list of built in audio drivers, in the order that they are normally initialized by default.</p>


</dd>
<dt id="getAudioDriver"><a name="getAudioDriver,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getAudioDriver</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetAudioDriver&quot;</span><span class="Other">,</span>
                                        <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Driver discovery procedures.</p>
<p>These procedures return the list of built in audio drivers, in the order that they are normally initialized by default.</p>


</dd>
<dt id="audioInit"><a name="audioInit,cstring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioInit</span><span class="Other">(</span><span class="Identifier">driver_name</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioInit&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Initialization.</p>
<p><tt class="docutils literal"><span class="pre">Internal:</span></tt> These procedures are used internally, and should not be used unless you have a specific need to specify the audio driver you want to use.  You should normally use <tt class="docutils literal"><span class="pre">init()</span></tt> or <tt class="docutils literal"><span class="pre">initSubSystem()</span></tt>.</p>


</dd>
<dt id="audioQuit"><a name="audioQuit,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioQuit</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioQuit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Cleanup.</p>
<p><tt class="docutils literal"><span class="pre">Internal</span></tt>: These procedures are used internally, and should not be used unless you have a specific need to specify the audio driver you want to use.  You should normally use <tt class="docutils literal"><span class="pre">init()</span></tt> or <tt class="docutils literal"><span class="pre">initSubSystem()</span></tt>.</p>


</dd>
<dt id="getCurrentAudioDriver"><a name="getCurrentAudioDriver,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getCurrentAudioDriver</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetCurrentAudioDriver&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This procedure returns the name of the current audio driver, or <cite>nil</cite> if no driver has been initialized.

</dd>
<dt id="openAudio"><a name="openAudio,ptr.AudioSpec,ptr.AudioSpec"></a><pre><span class="Keyword">proc</span> <span class="Identifier">openAudio</span><span class="Other">(</span><span class="Identifier">desired</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">;</span> <span class="Identifier">obtained</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_OpenAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>This procedure opens the audio device with the desired parameters, and returns <cite>0</cite> if successful, placing the actual hardware parameters in the object pointed to by <tt class="docutils literal"><span class="pre">obtained</span></tt>.  If <tt class="docutils literal"><span class="pre">obtained</span></tt> is <cite>nil</cite>, the audio data passed to the callback procedure will be guaranteed to be in the requested format, and will be automatically converted to the hardware audio format if necessary.  This procedure returns <cite>-1</cite> if it failed to open the audio device, or couldn't set up the audio thread.</p>
<p>When filling in the <tt class="docutils literal"><span class="pre">desired</span></tt> audio spec object,</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">desired.freq</span></tt> should be the desired audio frequency in samples-per- second.</li>
<li><tt class="docutils literal"><span class="pre">desired.format</span></tt> should be the desired audio format.</li>
<li><p><tt class="docutils literal"><span class="pre">desired.samples</span></tt> is the desired size of the audio buffer, in samples.  This number should be a power of two, and may be adjusted by the audio driver to a value more suitable for the hardware. Good values seem to range between <cite>512</cite> and <cite>8096</cite> inclusive, depending on the  application and CPU speed.  Smaller values yield faster response time, but can lead to underflow if the application is doing heavy processing and cannot fill the audio buffer in time.  A stereo sample consists of both right and left channels in LR ordering.</p>
<p>Note that the number of samples is directly related to time by the following formula:</p>
<p><cite>ms = (samples*1000)/freq</cite></p>
</li>
<li><tt class="docutils literal"><span class="pre">desired.size</span></tt> is the size in bytes of the audio buffer, and is calculated by <tt class="docutils literal"><span class="pre">openAudio()</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">desired.silence</span></tt> is the value used to set the buffer to silence, and is calculated by <tt class="docutils literal"><span class="pre">openAudio()</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">desired.callback</span></tt> should be set to a procedure that will be called when the audio device is ready for more data.  It is passed a pointer to the audio buffer, and the length in bytes of the audio buffer. This procedure usually runs in a separate thread, and so you should protect data structures that it accesses by calling <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> and <tt class="docutils literal"><span class="pre">unlockAudio()</span></tt> in your code. Alternately, you may pass a <cite>nil</cite> pointer here, and call <tt class="docutils literal"><span class="pre">queueAudio()</span></tt> with some frequency, to queue more audio samples to be played (or for capture devices, call <tt class="docutils literal"><span class="pre">sdl.dequeueAudio()</span></tt> with some frequency, to obtain audio samples).</li>
<li><tt class="docutils literal"><span class="pre">desired.userdata</span></tt> is passed as the first parameter to your callback procedure. If you passed a <cite>nil</cite> callback, this value is ignored.</li>
</ul>
<p>The audio device starts out playing silence when it's opened, and should be enabled for playing by calling <tt class="docutils literal"><span class="pre">pauseAudio(0)</span></tt> when you are ready for your audio callback procedure to be called.  Since the audio driver may modify the requested size of the audio buffer, you should allocate any local mixing buffers after you open the audio device.</p>


</dd>
<dt id="getNumAudioDevices"><a name="getNumAudioDevices,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getNumAudioDevices</span><span class="Other">(</span><span class="Identifier">iscapture</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetNumAudioDevices&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Get the number of available devices exposed by the current driver.</p>
<p>Only valid after a successfully initializing the audio subsystem. Returns <cite>-1</cite> if an explicit list of devices can't be determined; this is not an error. For example, if SDL is set up to talk to a remote audio server, it can't list every one available on the Internet, but it will still allow a specific host to be specified to <tt class="docutils literal"><span class="pre">openAudioDevice()</span></tt>.</p>
<p>In many common cases, when this procedure returns a value &lt;= <cite>0</cite>, it can still  successfully open the default device (<cite>nil</cite> for first argument of <tt class="docutils literal"><span class="pre">openAudioDevice()</span></tt>).</p>


</dd>
<dt id="getAudioDeviceName"><a name="getAudioDeviceName,cint,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getAudioDeviceName</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">iscapture</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetAudioDeviceName&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Get the human-readable name of a specific audio device.</p>
<p>Must be a value between <cite>0</cite> and <cite>(number of audio devices-1)</cite>. Only valid after a successfully initializing the audio subsystem. The values returned by this procedure reflect the latest call to <tt class="docutils literal"><span class="pre">getNumAudioDevices()</span></tt>; recall that procedure to redetect available hardware.</p>
<p>The string returned by this procedure is UTF-8 encoded, read-only, and managed internally. You are not to free it. If you need to keep the string for any length of time, you should make your own copy of it, as it will be invalid next time any of several other SDL prodedures is called.</p>


</dd>
<dt id="openAudioDevice"><a name="openAudioDevice,cstring,cint,ptr.AudioSpec,ptr.AudioSpec,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">openAudioDevice</span><span class="Other">(</span><span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">iscapture</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">desired</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">;</span>
                    <span class="Identifier">obtained</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">;</span> <span class="Identifier">allowed_changes</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_OpenAudioDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Open a specific audio device.</p>
<p>Passing in a device name of <cite>nil</cite> requests the most reasonable default (and is equivalent to calling <tt class="docutils literal"><span class="pre">openAudio()</span></tt>).</p>
<p>The device name is a UTF-8 string reported by <tt class="docutils literal"><span class="pre">getAudioDeviceName()</span></tt>, but some drivers allow arbitrary and driver-specific strings, such as a hostname/IP address for a remote audio server, or a filename in the diskaudio driver.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> on error, a valid device ID that is &gt;= <cite>2</cite> on success.</p>
<p><tt class="docutils literal"><span class="pre">openAudio()</span></tt>, unlike this procedure, always acts on device ID <cite>1</cite>.</p>


</dd>
<dt id="GetAudioStatus"><a name="GetAudioStatus,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">GetAudioStatus</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="audio.html#AudioStatus"><span class="Identifier">AudioStatus</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetAudioStatus&quot;</span><span class="Other">,</span>
                                  <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
Get the current audio state.

</dd>
<dt id="GetAudioDeviceStatus"><a name="GetAudioDeviceStatus,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">GetAudioDeviceStatus</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span><span class="Other">:</span> <a href="audio.html#AudioStatus"><span class="Identifier">AudioStatus</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetAudioDeviceStatus&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
Get the current audio state.

</dd>
<dt id="pauseAudio"><a name="pauseAudio,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pauseAudio</span><span class="Other">(</span><span class="Identifier">pause_on</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_PauseAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Pause audio procedures.</p>
<p>These procedures pause and unpause the audio callback processing. They should be called with a parameter of <cite>0</cite> after opening the audio device to start playing sound.  This is so you can safely initialize data for your callback procedure after opening the audio device. Silence will be written to the audio device during the pause.</p>


</dd>
<dt id="pauseAudioDevice"><a name="pauseAudioDevice,AudioDeviceID,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">pauseAudioDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">;</span> <span class="Identifier">pause_on</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_PauseAudioDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Pause audio procedures.</p>
<p>These procedures pause and unpause the audio callback processing. They should be called with a parameter of <cite>0</cite> after opening the audio device to start playing sound.  This is so you can safely initialize data for your callback procedure after opening the audio device. Silence will be written to the audio device during the pause.</p>


</dd>
<dt id="loadWAV_RW"><a name="loadWAV_RW,ptr.RWops,cint,ptr.AudioSpec,ptr.ptr.uint8,ptr.uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">loadWAV_RW</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">spec</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">;</span>
               <span class="Identifier">audio_buf</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">audio_len</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_LoadWAV_RW&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This procedure loads a WAVE from the data source, automatically freeing that source if <tt class="docutils literal"><span class="pre">freesrc</span></tt> is non-zero.  For example, to load a WAVE file, you could do:<blockquote><p>loadWAV_RW(rwFromFile(&quot;sample.wav&quot;, &quot;rb&quot;), 1, ...)</p></blockquote>
<p>If this procedure succeeds, it returns the given AudioSpec, filled with the audio data format of the wave data, and sets <tt class="docutils literal"><span class="pre">audio_buf[]</span></tt> to a malloc()'d buffer containing the audio data, and sets <tt class="docutils literal"><span class="pre">audio_len[]</span></tt> to the length of that audio buffer, in bytes. You need to free the audio buffer with <tt class="docutils literal"><span class="pre">freeWAV()</span></tt> when you are done with it.</p>
<p>This procedure returns <cite>nil</cite> and sets the SDL error message if the wave file cannot be opened, uses an unknown data format, or is corrupt.  Currently raw and MS-ADPCM WAVE files are supported.</p>


</dd>
<dt id="freeWAV"><a name="freeWAV,ptr.uint8"></a><pre><span class="Keyword">proc</span> <span class="Identifier">freeWAV</span><span class="Other">(</span><span class="Identifier">audio_buf</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_FreeWAV&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This procedure frees data previously allocated with <tt class="docutils literal"><span class="pre">loadWAV_RW()</span></tt>

</dd>
<dt id="buildAudioCVT"><a name="buildAudioCVT,ptr.AudioCVT,AudioFormat,uint8,cint,AudioFormat,uint8,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">buildAudioCVT</span><span class="Other">(</span><span class="Identifier">cvt</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioCVT"><span class="Identifier">AudioCVT</span></a><span class="Other">;</span> <span class="Identifier">src_format</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">;</span> <span class="Identifier">src_channels</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span>
                  <span class="Identifier">src_rate</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">dst_format</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">;</span> <span class="Identifier">dst_channels</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span>
                  <span class="Identifier">dst_rate</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_BuildAudioCVT&quot;</span><span class="Other">,</span>
                                       <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>This procedure takes a source format and rate and a destination format and rate, and initializes the <tt class="docutils literal"><span class="pre">cvt</span></tt> object with information needed by <tt class="docutils literal"><span class="pre">convertAudio()</span></tt> to convert a buffer of audio data from one format to the other. An unsupported format causes an error and <cite>-1</cite> will be returned.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> if no conversion is needed, <cite>1</cite> if the audio filter is set up, or <cite>-1</cite> on error.</p>


</dd>
<dt id="convertAudio"><a name="convertAudio,ptr.AudioCVT"></a><pre><span class="Keyword">proc</span> <span class="Identifier">convertAudio</span><span class="Other">(</span><span class="Identifier">cvt</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioCVT"><span class="Identifier">AudioCVT</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_ConvertAudio&quot;</span><span class="Other">,</span>
                                        <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Once you have initialized the <tt class="docutils literal"><span class="pre">cvt</span></tt> object using <tt class="docutils literal"><span class="pre">buildAudioCVT()</span></tt>, created an audio buffer <tt class="docutils literal"><span class="pre">cvt.buf</span></tt>, and filled it with <tt class="docutils literal"><span class="pre">cvt.len</span></tt> bytes of audio data in the source format, this procedure will convert it in-place to the desired format.</p>
<p>The data conversion may expand the size of the audio data, so the buffer <tt class="docutils literal"><span class="pre">cvt.buf</span></tt> should be allocated after the <tt class="docutils literal"><span class="pre">cvt</span></tt> object is initialized by <tt class="docutils literal"><span class="pre">buildAudioCVT()</span></tt>, and should be <cite>cvt.len*cvt.len_mult</cite> bytes long.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> on success or <cite>-1</cite> if <tt class="docutils literal"><span class="pre">cvt.buf</span></tt> is <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>


</dd>
<dt id="newAudioStream"><a name="newAudioStream,AudioFormat,uint8,cint,AudioFormat,uint8,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">newAudioStream</span><span class="Other">(</span><span class="Identifier">srcFormat</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">;</span> <span class="Identifier">srcChannels</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">srcRate</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                   <span class="Identifier">dstFormat</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">;</span> <span class="Identifier">dstChannels</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">dstRate</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_NewAudioStream&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="audioStreamPut"><a name="audioStreamPut,AudioStream,pointer,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioStreamPut</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">;</span> <span class="Identifier">buf</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioStreamPut&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="audioStreamGet"><a name="audioStreamGet,AudioStream,pointer,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioStreamGet</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">;</span> <span class="Identifier">buf</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioStreamGet&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="audioStreamAvailable"><a name="audioStreamAvailable,AudioStream"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioStreamAvailable</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioStreamAvailable&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="audioStreamFlush"><a name="audioStreamFlush,AudioStream"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioStreamFlush</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioStreamFlush&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="audioStreamClear"><a name="audioStreamClear,AudioStream"></a><pre><span class="Keyword">proc</span> <span class="Identifier">audioStreamClear</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_AudioStreamClear&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="freeAudioStream"><a name="freeAudioStream,AudioStream"></a><pre><span class="Keyword">proc</span> <span class="Identifier">freeAudioStream</span><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="audio.html#AudioStream"><span class="Identifier">AudioStream</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_FreeAudioStream&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>


</dd>
<dt id="mixAudio"><a name="mixAudio,ptr.uint8,ptr.uint8,uint32,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mixAudio</span><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> <span class="Identifier">volume</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_MixAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This takes two audio buffers of the playing audio format and mixes them, performing addition, volume adjustment, and overflow clipping. The volume ranges from <cite>0 - 128</cite>, and should be set to <cite>MIX_MAXVOLUME</cite> for full audio volume.  Note this does not change hardware volume. This is provided for convenience -- you can mix your own audio data.

</dd>
<dt id="mixAudioFormat"><a name="mixAudioFormat,ptr.uint8,ptr.uint8,AudioFormat,uint32,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">mixAudioFormat</span><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">format</span><span class="Other">:</span> <a href="audio.html#AudioFormat"><span class="Identifier">AudioFormat</span></a><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span>
                   <span class="Identifier">volume</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_MixAudioFormat&quot;</span><span class="Other">,</span>
                                 <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This works like <tt class="docutils literal"><span class="pre">mixAudio()</span></tt>, but you specify the audio format instead of using the format of audio device <cite>1</cite>. Thus it can be used when no audio device is open at all.

</dd>
<dt id="queueAudio"><a name="queueAudio,AudioDeviceID,pointer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">queueAudio</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_QueueAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Queue more audio on non-callback devices.</p>
<p>(If you are looking to retrieve queued audio from a non-callback capture device, you want <tt class="docutils literal"><span class="pre">sdl.dequeueAudio()</span></tt> instead. This will return <cite>-1</cite> to signify an error if you use it with capture devices.)</p>
<p>SDL offers two ways to feed audio to the device: you can either supply a callback that SDL triggers with some frequency to obtain more audio (pull method), or you can supply no callback, and then SDL will expect you to supply data at regular intervals (push method) with this procedure.</p>
<p>There are no limits on the amount of data you can queue, short of exhaustion of address space. Queued data will drain to the device as necessary without further intervention from you. If the device needs audio but there is not enough queued, it will play silence to make up the difference. This means you will have skips in your audio playback if you aren't routinely queueing sufficient data.</p>
<p>This procedure copies the supplied data, so you are safe to free it when the procedure returns. This procedure is thread-safe, but queueing to the same device from two threads at once does not promise which buffer will be queued first.</p>
<p>You may not queue audio on a device that is using an application-supplied callback; doing so returns an error. You have to use the audio callback or queue audio with this procedure, but not both.</p>
<p>You should not call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> on the device before queueing; SDL handles locking internally for this procedure.</p>
<p><tt class="docutils literal"><span class="pre">dev</span></tt> The device ID to which we will queue audio.</p>
<p><tt class="docutils literal"><span class="pre">data</span></tt> The data to queue to the device for later playback.</p>
<p><tt class="docutils literal"><span class="pre">len</span></tt> The number of bytes (not samples!) to which (data) points.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <cite>0</cite> on success, <cite>-1</cite> on error.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">getQueuedAudioSize()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">clearQueuedAudio()</span></tt></p>


</dd>
<dt id="dequeueAudio"><a name="dequeueAudio,AudioDeviceID,pointer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">dequeueAudio</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_DequeueAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Dequeue more audio on non-callback devices.</p>
<p>(If you are looking to queue audio for output on a non-callback playback device, you want <tt class="docutils literal"><span class="pre">sdl.queueAudio()</span></tt> instead. This will always return <cite>0</cite> if you use it with playback devices.)</p>
<p>SDL offers two ways to retrieve audio from a capture device: you can either supply a callback that SDL triggers with some frequency as the device records more audio data, (push method), or you can supply no callback, and then SDL will expect you to retrieve data at regular intervals (pull method) with this procedure.</p>
<p>There are no limits on the amount of data you can queue, short of exhaustion of address space. Data from the device will keep queuing as necessary without further intervention from you. This means you will eventually run out of memory if you aren't routinely dequeueing data.</p>
<p>Capture devices will not queue data when paused; if you are expecting to not need captured audio for some length of time, use <tt class="docutils literal"><span class="pre">sdl.pauseAudioDevice()</span></tt> to stop the capture device from queueing more data. This can be useful during, say, level loading times. When unpaused, capture devices will start queueing data from that point, having flushed any capturable data available while paused.</p>
<p>This procedure is thread-safe, but dequeueing from the same device from two threads at once does not promise which thread will dequeued data first.</p>
<p>You may not dequeue audio from a device that is using an application-supplied callback; doing so returns an error. You have to use the audio callback, or dequeue audio with this procedure, but not both.</p>
<p>You should not call <tt class="docutils literal"><span class="pre">sdl.lockAudio()</span></tt> on the device before queueing; SDL handles locking internally for this function.</p>
<p><tt class="docutils literal"><span class="pre">dev</span></tt> The device ID from which we will dequeue audio. <tt class="docutils literal"><span class="pre">data</span></tt> A pointer into where audio data should be copied. <tt class="docutils literal"><span class="pre">len</span></tt> The number of bytes (not samples!) to which (data) points. <tt class="docutils literal"><span class="pre">Return</span></tt> number of bytes dequeued, which could be less than requested.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">getQueuedAudioSize</span></tt> <tt class="docutils literal"><span class="pre">clearQueuedAudio</span></tt></p>


</dd>
<dt id="getQueuedAudioSize"><a name="getQueuedAudioSize,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">getQueuedAudioSize</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_GetQueuedAudioSize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Get the number of bytes of still-queued audio.</p>
<p>For playback device:</p>
<blockquote><p><p>This is the number of bytes that have been queued for playback with <tt class="docutils literal"><span class="pre">sdl.queueAudio()</span></tt>, but have not yet been sent to the hardware. This number may shrink at any time, so this only informs of pending data.</p>
<p>Once we've sent it to the hardware, this procedure can not decide the exact byte boundary of what has been played. It's possible that we just gave the hardware several kilobytes right before you called this procedure, but it hasn't played any of it yet, or maybe half of it, etc.</p>
</p></blockquote>
<p>For capture device:</p>
<blockquote><p>This is the number of bytes that have been captured by the device and are waiting for you to dequeue. This number may grow at any time, so this only informs of the lower-bound of available data.</p></blockquote>
<p>You may not queue audio on a device that is using an application-supplied callback; calling this procedure on such a device always returns <cite>0</cite>. You have to queue audio with <tt class="docutils literal"><span class="pre">sdl.queueAudio()</span></tt> / <tt class="docutils literal"><span class="pre">sdl.dequeueAudio()</span></tt>, or use the audio callback,  but not both.</p>
<p>You should not call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> on the device before querying; SDL handles locking internally for this procedure.</p>
<p><tt class="docutils literal"><span class="pre">dev</span></tt> The device ID of which we will query queued audio size.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> number of bytes (not samples!) of queued audio.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">queueAudio()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">clearQueuedAudio()</span></tt></p>


</dd>
<dt id="clearQueuedAudio"><a name="clearQueuedAudio,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">clearQueuedAudio</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_ClearQueuedAudio&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Drop any queued audio data. For playback devices, this is any queued data still waiting to be submitted to the hardware. For capture devices, this is any data that was queued by the device that hasn't yet been dequeued by the application.</p>
<p>Immediately after this call, <tt class="docutils literal"><span class="pre">sdl.getQueuedAudioSize()</span></tt> will return <cite>0</cite>. For playback devices, the hardware will start playing silence if more audio isn't queued. Unpaused capture devices will start filling the queue again as soon as they have more data available (which, depending on the state of the hardware and the thread, could be before this function call returns!).</p>
<p>This will not prevent playback of queued audio that's already been sent to the hardware, as we can not undo that, so expect there to be some fraction of a second of audio that might still be heard. This can be useful if you want to, say, drop any pending music during a level change in your game.</p>
<p>You may not queue audio on a device that is using an application-supplied callback; calling this procedure on such a device is always a no-op. You have to queue audio with <tt class="docutils literal"><span class="pre">sdl.queueAudio()</span></tt> / <tt class="docutils literal"><span class="pre">sdl.dequeueAudio()</span></tt>, or use the audio callback, but not both.</p>
<p>You should not call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> on the device before clearing the queue; SDL handles locking internally for this procedure.</p>
<p>This procedure always succeeds and thus returns nothing.</p>
<p><tt class="docutils literal"><span class="pre">dev</span></tt> The device ID of which to clear the audio queue.</p>
<p>See also:</p>
<p><tt class="docutils literal"><span class="pre">queueAudio()</span></tt></p>
<p><tt class="docutils literal"><span class="pre">getQueuedAudioSize()</span></tt></p>


</dd>
<dt id="lockAudio"><a name="lockAudio,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">lockAudio</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_LockAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Audio lock procedure.</p>
<p>The lock manipulated by these procedures protects the callback procedure. During a <tt class="docutils literal"><span class="pre">lockAudio()</span></tt>/<tt class="docutils literal"><span class="pre">unlockAudio()</span></tt> pair, you can be guaranteed that the callback procedure is not running.  Do not call these from the callback procedure or you will cause deadlock.</p>


</dd>
<dt id="lockAudioDevice"><a name="lockAudioDevice,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">lockAudioDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_LockAudioDevice&quot;</span><span class="Other">,</span>
                                        <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Audio lock procedure.</p>
<p>The lock manipulated by these procedures protects the callback procedure. During a <tt class="docutils literal"><span class="pre">lockAudio()</span></tt>/<tt class="docutils literal"><span class="pre">unlockAudio()</span></tt> pair, you can be guaranteed that the callback procedure is not running.  Do not call these from the callback procedure or you will cause deadlock.</p>


</dd>
<dt id="unlockAudio"><a name="unlockAudio,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">unlockAudio</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_UnlockAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Audio unlock procedure.</p>
<p>The lock manipulated by these procedures protects the callback procedure. During a <tt class="docutils literal"><span class="pre">lockAudio()</span></tt>/<tt class="docutils literal"><span class="pre">unlockAudio()</span></tt> pair, you can be guaranteed that the callback procedure is not running.  Do not call these from the callback procedure or you will cause deadlock.</p>


</dd>
<dt id="unlockAudioDevice"><a name="unlockAudioDevice,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">unlockAudioDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_UnlockAudioDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
<p>Audio unlock procedure.</p>
<p>The lock manipulated by these procedures protects the callback procedure. During a <tt class="docutils literal"><span class="pre">lockAudio()</span></tt>/<tt class="docutils literal"><span class="pre">unlockAudio()</span></tt> pair, you can be guaranteed that the callback procedure is not running.  Do not call these from the callback procedure or you will cause deadlock.</p>


</dd>
<dt id="closeAudio"><a name="closeAudio,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">closeAudio</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_CloseAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This procedure shuts down audio processing and closes the audio device.

</dd>
<dt id="closeAudioDevice"><a name="closeAudioDevice,AudioDeviceID"></a><pre><span class="Keyword">proc</span> <span class="Identifier">closeAudioDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <a href="audio.html#AudioDeviceID"><span class="Identifier">AudioDeviceID</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;SDL_CloseAudioDevice&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
This procedure shuts down audio processing and closes the audio device.

</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<dt id="audioBitSize"><a name="audioBitSize.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioBitSize</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsFloat"><a name="audioIsFloat.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsFloat</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsBigEndian"><a name="audioIsBigEndian.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsBigEndian</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsSigned"><a name="audioIsSigned.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsSigned</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsInt"><a name="audioIsInt.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsInt</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsLittleEndian"><a name="audioIsLittleEndian.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsLittleEndian</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="audioIsUnsigned"><a name="audioIsUnsigned.t,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">audioIsUnsigned</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


</dd>
<dt id="loadWAV_RW"><a name="loadWAV_RW.t,ptr.RWops,bool,ptr.AudioSpec,ptr.ptr.uint8,ptr.uint32"></a><pre><span class="Keyword">template</span> <span class="Identifier">loadWAV_RW</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span> <span class="Identifier">spec</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a><span class="Other">;</span>
                   <span class="Identifier">audio_buf</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">audio_len</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="audio.html#AudioSpec"><span class="Identifier">AudioSpec</span></a></pre></dt>
<dd>


</dd>
<dt id="loadWAV"><a name="loadWAV.t,untyped,untyped,untyped,untyped"></a><pre><span class="Keyword">template</span> <span class="Identifier">loadWAV</span><span class="Other">(</span><span class="Identifier">file</span><span class="Other">,</span> <span class="Identifier">spec</span><span class="Other">,</span> <span class="Identifier">audio_buf</span><span class="Other">,</span> <span class="Identifier">audio_len</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>
<p>
Loads a WAV from a file.</p>
<p>Compatibility convenience template.</p>


</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2018-11-02 19:11:01 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
